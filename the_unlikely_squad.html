<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Unlikely Squad</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            overflow: hidden;
        }
        canvas {
            display: block;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
        }
    </style>
</head>
<body>
    <div class="fixed inset-0 pointer-events-none">
        <!-- Character Selection UI -->
        <div class="absolute top-4 left-4 flex space-x-2 pointer-events-auto">
            <div id="char1" class="w-12 h-12 bg-red-500 rounded border-2 border-white flex items-center justify-center text-white font-bold cursor-pointer">1</div>
            <div id="char2" class="w-12 h-12 bg-blue-400 rounded border-2 border-gray-400 flex items-center justify-center text-white font-bold cursor-pointer">2</div>
            <div id="char3" class="w-12 h-12 bg-green-500 rounded border-2 border-gray-400 flex items-center justify-center text-white font-bold cursor-pointer">3</div>
            <div id="char4" class="w-12 h-12 bg-purple-500 rounded border-2 border-gray-400 flex items-center justify-center text-white font-bold cursor-pointer">4</div>
        </div>

        <!-- Tutorial Messages -->
        <div id="tutorialMessage" class="absolute top-20 left-4 right-4 bg-black bg-opacity-75 text-white p-4 rounded hidden pointer-events-auto">
            <p id="tutorialText"></p>
        </div>

        <!-- Game Over/Complete Message -->
        <div id="gameMessage" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden pointer-events-auto">
            <div class="bg-white p-8 rounded-lg text-center">
                <h2 id="gameMessageTitle" class="text-2xl font-bold mb-4"></h2>
                <p id="gameMessageText" class="mb-4"></p>
                <button onclick="restartGame()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Restart</button>
            </div>
        </div>

        <!-- Coordinates Display -->
        <div id="coordinates" class="absolute top-4 right-4 text-white text-sm bg-black bg-opacity-75 p-2 rounded pointer-events-auto">
            <div>X: <span id="coordX">0</span> | Y: <span id="coordY">0</span></div>
            <div>Character: <span id="coordChar">1</span></div>
        </div>

        <!-- Controls Info -->
        <div class="absolute bottom-4 left-4 text-white text-sm bg-black bg-opacity-50 p-2 rounded pointer-events-auto">
            <div>Arrow Keys: Move | Up: Jump | Space: Primary Ability | C: Secondary (Primm)</div>
            <div>1-4: Switch Characters | R: Restart</div>
        </div>
    </div>

    <canvas id="gameCanvas" width="1200" height="800"></canvas>

    <script>
        // Game Engine
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                this.camera = { x: 0, y: 0 };
                this.keys = {};
                this.currentCharacter = 0;
                this.characters = [];
                this.enemies = [];
                this.platforms = [];
                this.objects = [];
                this.projectiles = [];
                
                this.gravity = 0.8;
                this.friction = 0.8;
                
                this.initCharacters();
                this.initLevel();
                this.bindEvents();
                this.gameLoop();
            }

            initCharacters() {
                // Mister Underpants (Red)
                this.characters.push({
                    name: 'Mister Underpants',
                    x: 100, y: 400,
                    width: 30, height: 40,
                    color: '#ef4444',
                    vx: 0, vy: 0,
                    onGround: false,
                    speed: 5,
                    jumpPower: 15,
                    flightFuel: 100,
                    maxFlightFuel: 100,
                    abilities: ['fly', 'shoot']
                });

                // Windman (Light Blue)
                this.characters.push({
                    name: 'Windman',
                    x: 100, y: 400,
                    width: 30, height: 40,
                    color: '#60a5fa',
                    vx: 0, vy: 0,
                    onGround: false,
                    speed: 5,
                    jumpPower: 15,
                    abilities: ['wind']
                });

                // Teibi (Green)
                this.characters.push({
                    name: 'Teibi',
                    x: 100, y: 400,
                    width: 30, height: 40,
                    color: '#22c55e',
                    vx: 0, vy: 0,
                    onGround: false,
                    speed: 5,
                    jumpPower: 15,
                    isSmall: false,
                    normalWidth: 30,
                    normalHeight: 40,
                    smallWidth: 15,
                    smallHeight: 20,
                    abilities: ['shrink']
                });

                // Primm (Purple)
                this.characters.push({
                    name: 'Primm',
                    x: 100, y: 400,
                    width: 30, height: 40,
                    color: '#a855f7',
                    vx: 0, vy: 0,
                    onGround: false,
                    speed: 5,
                    jumpPower: 15,
                    dashCooldown: 0,
                    phasing: false,
                    abilities: ['dash', 'phase']
                });
            }

            initLevel() {
                // Starting area - multiple platforms for warmup
                this.platforms.push({x: 0, y: 650, width: 300, height: 150, color: '#8b4513'});
                this.platforms.push({x: 200, y: 550, width: 120, height: 20, color: '#654321'});
                this.platforms.push({x: 380, y: 480, width: 80, height: 20, color: '#654321'});
                this.platforms.push({x: 520, y: 420, width: 100, height: 20, color: '#654321'});
                
                // Teibi section - more interesting wall design
                this.platforms.push({x: 700, y: 350, width: 150, height: 20, color: '#654321'});
                this.platforms.push({x: 900, y: 650, width: 200, height: 150, color: '#8b4513'});
                
                // The "first wall" - a more obvious crawl space
                this.platforms.push({x: 850, y: 400, width: 30, height: 220, color: '#555'});
                this.platforms.push({x: 850, y: 620, width: 30, height: 30, color: '#555', gap: true});
                
                // Add some decorative elements around the gap
                this.objects.push({
                    type: 'decoration',
                    x: 820, y: 615,
                    width: 25, height: 10,
                    color: '#8b4513'
                });
                this.objects.push({
                    type: 'sign',
                    x: 750, y: 310,
                    width: 40, height: 30,
                    color: '#d4a574',
                    text: 'Small passage ahead!'
                });

                // More platforming after Teibi section
                this.platforms.push({x: 1150, y: 550, width: 100, height: 20, color: '#654321'});
                this.platforms.push({x: 1300, y: 480, width: 80, height: 20, color: '#654321'});
                this.platforms.push({x: 1450, y: 420, width: 120, height: 20, color: '#654321'});

                // Mister Underpants section - wide chasm with interesting terrain
                this.platforms.push({x: 1650, y: 650, width: 100, height: 150, color: '#8b4513'});
                // Add intermediate platform to make crossing easier
                this.platforms.push({x: 1900, y: 620, width: 80, height: 20, color: '#654321'});
                this.platforms.push({x: 2050, y: 580, width: 80, height: 20, color: '#654321'});
                this.platforms.push({x: 2200, y: 520, width: 100, height: 20, color: '#654321'});
                this.platforms.push({x: 2350, y: 650, width: 200, height: 150, color: '#8b4513'});

                // More vertical platforming - fix gaps
                this.platforms.push({x: 2550, y: 600, width: 100, height: 20, color: '#654321'});
                this.platforms.push({x: 2700, y: 540, width: 100, height: 20, color: '#654321'});
                
                // Add wind platform to help cross the gap
                this.objects.push({
                    type: 'windPlatform',
                    x: 2820, y: 520,
                    width: 80, height: 15,
                    color: '#87CEEB',
                    activated: false,
                    targetY: 420
                });
                
                this.platforms.push({x: 2950, y: 480, width: 100, height: 20, color: '#654321'});
                this.platforms.push({x: 3100, y: 580, width: 80, height: 20, color: '#654321'});

                // Primm section with phase walls
                this.platforms.push({x: 3120, y: 650, width: 150, height: 150, color: '#8b4513'});
                
                this.objects.push({
                    type: 'phaseWall',
                    x: 3270, y: 450,
                    width: 25, height: 200,
                    color: 'rgba(138, 43, 226, 0.6)'
                });
                
                this.platforms.push({x: 3350, y: 580, width: 100, height: 20, color: '#654321'});
                this.platforms.push({x: 3500, y: 520, width: 80, height: 20, color: '#654321'});

                // Final Windman section - elevated goal platform
                this.platforms.push({x: 3600, y: 650, width: 200, height: 150, color: '#8b4513'});
                this.platforms.push({x: 3900, y: 300, width: 150, height: 20, color: '#654321'}); // High goal platform

                // Wind platform to reach the goal
                this.objects.push({
                    type: 'windPlatform',
                    x: 3700, y: 630,
                    width: 100, height: 15,
                    color: '#87CEEB',
                    activated: false,
                    targetY: 400
                });

                // Goal on the high platform
                this.objects.push({
                    type: 'goal',
                    x: 3950, y: 250,
                    width: 50, height: 50,
                    color: '#ffd700'
                });

                // Add some collectible coins for fun
                this.objects.push({type: 'coin', x: 250, y: 520, width: 15, height: 15, color: '#ffd700', collected: false});
                this.objects.push({type: 'coin', x: 750, y: 320, width: 15, height: 15, color: '#ffd700', collected: false});
                this.objects.push({type: 'coin', x: 2100, y: 550, width: 15, height: 15, color: '#ffd700', collected: false});
                this.objects.push({type: 'coin', x: 3350, y: 550, width: 15, height: 15, color: '#ffd700', collected: false});

                // More interesting enemy placement
                this.enemies.push({
                    x: 1200, y: 530,
                    width: 25, height: 25,
                    color: '#dc2626',
                    vx: 1.5,
                    patrol: {min: 1150, max: 1350},
                    alive: true
                });

                this.enemies.push({
                    x: 2100, y: 495,
                    width: 25, height: 25,
                    color: '#dc2626',
                    vx: 2,
                    patrol: {min: 2050, max: 2300},
                    alive: true
                });

                this.enemies.push({
                    x: 3350, y: 555,
                    width: 25, height: 25,
                    color: '#dc2626',
                    vx: 1,
                    patrol: {min: 3300, max: 3450},
                    alive: true
                });
            }

            bindEvents() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    this.handleKeyPress(e.code);
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Character selection clicks
                for (let i = 1; i <= 4; i++) {
                    document.getElementById(`char${i}`).addEventListener('click', () => {
                        this.switchCharacter(i - 1);
                    });
                }
            }

            handleKeyPress(key) {
                // Character switching
                if (key === 'Digit1') this.switchCharacter(0);
                if (key === 'Digit2') this.switchCharacter(1);
                if (key === 'Digit3') this.switchCharacter(2);
                if (key === 'Digit4') this.switchCharacter(3);

                // Primary ability
                if (key === 'Space') {
                    this.useAbility();
                }

                // Secondary ability (Primm only)
                if (key === 'KeyC') {
                    if (this.currentCharacter === 3) {
                        this.characters[3].phasing = true;
                    }
                }

                // Restart game
                if (key === 'KeyR') {
                    this.restartGame();
                }
            }

            switchCharacter(index) {
                const oldChar = this.characters[this.currentCharacter];
                this.currentCharacter = index;
                const newChar = this.characters[this.currentCharacter];
                
                // Move new character to old character's position
                newChar.x = oldChar.x;
                newChar.y = oldChar.y;
                newChar.vx = 0;
                newChar.vy = oldChar.vy;

                // Update UI
                for (let i = 1; i <= 4; i++) {
                    const elem = document.getElementById(`char${i}`);
                    elem.classList.toggle('border-white', i - 1 === index);
                    elem.classList.toggle('border-gray-400', i - 1 !== index);
                }

                this.showTutorial();
            }

            useAbility() {
                const char = this.characters[this.currentCharacter];
                
                switch(this.currentCharacter) {
                    case 0: // Mister Underpants - Shoot
                        this.shoot();
                        break;
                    case 1: // Windman - Wind Gust
                        this.windGust();
                        break;
                    case 2: // Teibi - Shrink
                        this.toggleShrink();
                        break;
                    case 3: // Primm - Dash
                        this.dash();
                        break;
                }
            }

            shoot() {
                const char = this.characters[0];
                this.projectiles.push({
                    x: char.x + char.width,
                    y: char.y + char.height / 2,
                    width: 8,
                    height: 4,
                    vx: 10,
                    color: '#fbbf24'
                });
            }

            windGust() {
                const char = this.characters[1];
                const windRange = 150;
                const windForce = 8;
                
                // Create visual wind effect
                this.createWindEffect(char);
                
                // Check for nearby wind platforms
                this.objects.forEach(obj => {
                    if (obj.type === 'windPlatform' && 
                        Math.abs(obj.x - char.x) < 100 && 
                        Math.abs(obj.y - char.y) < 100) {
                        obj.activated = true;
                    }
                });
                
                // Blow away enemies in front of Windman
                this.enemies.forEach(enemy => {
                    if (!enemy.alive) return;
                    
                    const dx = enemy.x - char.x;
                    const dy = enemy.y - char.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if enemy is in front of Windman and within range
                    if (distance < windRange && dx > 0 && Math.abs(dy) < 60) {
                        // Push enemy away
                        enemy.x += windForce;
                        enemy.y -= 2; // Slight upward push
                        
                        // Temporarily disable enemy patrol to show they're being blown
                        enemy.stunned = 60; // 1 second of being stunned
                        enemy.vx = 0; // Stop normal movement
                    }
                });
            }
            
            createWindEffect(char) {
                // Add wind particles for visual feedback
                for (let i = 0; i < 8; i++) {
                    this.windParticles = this.windParticles || [];
                    this.windParticles.push({
                        x: char.x + char.width,
                        y: char.y + 15 + (Math.random() - 0.5) * 20,
                        vx: 4 + Math.random() * 3,
                        vy: (Math.random() - 0.5) * 2,
                        life: 30,
                        maxLife: 30
                    });
                }
            }

            toggleShrink() {
                const char = this.characters[2];
                char.isSmall = !char.isSmall;
                
                if (char.isSmall) {
                    char.width = char.smallWidth;
                    char.height = char.smallHeight;
                } else {
                    char.width = char.normalWidth;
                    char.height = char.normalHeight;
                }
            }

            dash() {
                const char = this.characters[3];
                if (char.dashCooldown <= 0) {
                    char.vx = 15;
                    char.dashCooldown = 60;
                    char.dashing = 15; // Dash lasts for 15 frames
                    
                    // Immediately check for enemies in current dash range
                    this.killEnemiesInDashPath(char);
                }
            }
            
            killEnemiesInDashPath(char) {
                // Check for enemies in dash path
                this.enemies.forEach(enemy => {
                    if (enemy.alive) {
                        const dx = Math.abs(enemy.x - char.x);
                        const dy = Math.abs(enemy.y - char.y);
                        
                        // Kill enemies within dash range
                        if (dx < 40 && dy < 40) {
                            enemy.alive = false;
                        }
                    }
                });
            }

            update() {
                const char = this.characters[this.currentCharacter];

                // Handle input
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    char.vx = -char.speed;
                }
                if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                    char.vx = char.speed;
                }
                if ((this.keys['ArrowUp'] || this.keys['KeyW']) && char.onGround) {
                    char.vy = -char.jumpPower;
                    char.onGround = false;
                }

                // Mister Underpants flight - fly up like a real superhero
                if (this.currentCharacter === 0 && 
                    (this.keys['ArrowUp'] || this.keys['KeyW']) && 
                    char.flightFuel > 0) {
                    char.vy = -8; // Fly upward
                    char.flightFuel -= 3;
                }

                // Primm phasing
                if (this.currentCharacter === 3 && !this.keys['KeyC']) {
                    char.phasing = false;
                }

                // Apply physics
                char.vy += this.gravity;
                char.vx *= this.friction;

                // Update position
                char.x += char.vx;
                char.y += char.vy;

                // Collision detection
                this.checkCollisions(char);

                // Update other systems
                this.updateEnemies();
                this.updateProjectiles();
                this.updateObjects();
                this.updateWindParticles();
                this.updateCamera();
                this.updateCooldowns();

                // Check win condition
                this.checkWinCondition();
                
                // Check if player fell off the level
                this.checkFallDeath();
                
                // Update coordinate display
                this.updateCoordinateDisplay();
            }

            checkCollisions(char) {
                char.onGround = false;

                // Platform collisions
                this.platforms.forEach(platform => {
                    if (platform.gap && this.currentCharacter === 2 && char.isSmall) {
                        return; // Small Teibi can pass through gaps
                    }

                    if (char.x < platform.x + platform.width &&
                        char.x + char.width > platform.x &&
                        char.y < platform.y + platform.height &&
                        char.y + char.height > platform.y) {
                        
                        // Top collision (landing on platform)
                        if (char.vy > 0 && char.y < platform.y) {
                            char.y = platform.y - char.height;
                            char.vy = 0;
                            char.onGround = true;
                        }
                        // Bottom collision
                        else if (char.vy < 0 && char.y > platform.y) {
                            char.y = platform.y + platform.height;
                            char.vy = 0;
                        }
                        // Side collisions
                        else if (char.vx > 0) {
                            char.x = platform.x - char.width;
                            char.vx = 0;
                        }
                        else if (char.vx < 0) {
                            char.x = platform.x + platform.width;
                            char.vx = 0;
                        }
                    }
                });

                // Object collisions
                this.objects.forEach(obj => {
                    if (char.x < obj.x + obj.width &&
                        char.x + char.width > obj.x &&
                        char.y < obj.y + obj.height &&
                        char.y + char.height > obj.y) {
                        
                        if (obj.type === 'coin' && !obj.collected) {
                            obj.collected = true;
                            // Could add score here
                        } else if (obj.type === 'windPlatform') {
                            // Wind platforms act like solid platforms you can stand on
                            if (char.vy > 0 && char.y < obj.y) {
                                char.y = obj.y - char.height;
                                char.vy = 0;
                                char.onGround = true;
                            }
                        } else if (obj.type === 'phaseWall' && 
                                   !(this.currentCharacter === 3 && char.phasing)) {
                            // Solid for non-phasing characters
                            if (char.vx > 0) {
                                char.x = obj.x - char.width;
                                char.vx = 0;
                            } else if (char.vx < 0) {
                                char.x = obj.x + obj.width;
                                char.vx = 0;
                            }
                        }
                    }
                });

                // Regenerate flight fuel when grounded
                if (char.onGround && this.currentCharacter === 0) {
                    char.flightFuel = Math.min(char.flightFuel + 1, char.maxFlightFuel);
                }
            }

            updateEnemies() {
                this.enemies.forEach(enemy => {
                    if (!enemy.alive) return;

                    // Handle stunned state (from wind)
                    if (enemy.stunned > 0) {
                        enemy.stunned--;
                        if (enemy.stunned === 0) {
                            // Resume normal patrol
                            enemy.vx = enemy.vx > 0 ? Math.abs(enemy.patrol.speed || 2) : -Math.abs(enemy.patrol.speed || 2);
                        }
                    } else {
                        // Normal movement
                        enemy.x += enemy.vx;
                        
                        // Patrol behavior
                        if (enemy.x <= enemy.patrol.min || enemy.x >= enemy.patrol.max) {
                            enemy.vx *= -1;
                        }
                    }

                    // Check collision with current character
                    const char = this.characters[this.currentCharacter];
                    if (char.x < enemy.x + enemy.width &&
                        char.x + char.width > enemy.x &&
                        char.y < enemy.y + enemy.height &&
                        char.y + char.height > enemy.y) {
                        
                        // Check if player is stomping (falling down and hitting from above)
                        if (char.vy > 0 && char.y < enemy.y - 5) {
                            // Player stomps enemy
                            enemy.alive = false;
                            char.vy = -8; // Bounce up after stomping
                        } else {
                            // Player dies from touching enemy from side/below
                            this.gameOver("You were caught by an enemy!");
                        }
                    }
                });
            }

            updateProjectiles() {
                this.projectiles = this.projectiles.filter(proj => {
                    proj.x += proj.vx;

                    // Check enemy hits
                    this.enemies.forEach(enemy => {
                        if (enemy.alive &&
                            proj.x < enemy.x + enemy.width &&
                            proj.x + proj.width > enemy.x &&
                            proj.y < enemy.y + enemy.height &&
                            proj.y + proj.height > enemy.y) {
                            enemy.alive = false;
                            proj.hit = true;
                        }
                    });

                    // Remove if hit or off screen
                    return !proj.hit && proj.x < this.camera.x + this.canvas.width;
                });
            }

            updateObjects() {
                this.objects.forEach(obj => {
                    if (obj.type === 'windPlatform' && obj.activated) {
                        if (obj.y > obj.targetY) {
                            obj.y -= 2;
                        }
                    }
                });
            }

            updateWindParticles() {
                if (!this.windParticles) return;
                
                this.windParticles = this.windParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    
                    // Fade out over time
                    particle.alpha = particle.life / particle.maxLife;
                    
                    return particle.life > 0;
                });
            }

            updateCamera() {
                const char = this.characters[this.currentCharacter];
                this.camera.x = char.x - this.canvas.width / 2;
                this.camera.y = char.y - this.canvas.height / 2;

                // Clamp camera
                this.camera.x = Math.max(0, this.camera.x);
                this.camera.y = Math.max(-200, Math.min(200, this.camera.y));
            }

            updateCooldowns() {
                const primm = this.characters[3];
                primm.dashCooldown = Math.max(0, primm.dashCooldown - 1);
                
                // Handle dashing state
                if (primm.dashing > 0) {
                    primm.dashing--;
                    // Continue killing enemies while dashing
                    if (this.currentCharacter === 3) {
                        this.killEnemiesInDashPath(primm);
                    }
                }
            }

            checkWinCondition() {
                const char = this.characters[this.currentCharacter];
                const goal = this.objects.find(obj => obj.type === 'goal');
                
                if (goal &&
                    char.x < goal.x + goal.width &&
                    char.x + char.width > goal.x &&
                    char.y < goal.y + goal.height &&
                    char.y + char.height > goal.y) {
                    this.gameComplete();
                }
            }

            checkFallDeath() {
                const char = this.characters[this.currentCharacter];
                const deathHeight = 900; // If player falls below this Y coordinate, they die
                
                if (char.y > deathHeight) {
                    this.gameOver("Oops! The squad member fell into the abyss!");
                }
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Save context for camera
                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                // Draw platforms
                this.platforms.forEach(platform => {
                    this.ctx.fillStyle = platform.color;
                    this.ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                });

                // Draw objects
                this.objects.forEach(obj => {
                    if (obj.type === 'coin' && obj.collected) return;
                    
                    this.ctx.fillStyle = obj.color;
                    this.ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                    
                    if (obj.type === 'goal') {
                        // Add sparkle effect
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(obj.x + 10, obj.y + 10, 5, 5);
                        this.ctx.fillRect(obj.x + 30, obj.y + 20, 5, 5);
                        this.ctx.fillRect(obj.x + 20, obj.y + 35, 5, 5);
                    } else if (obj.type === 'coin') {
                        // Add coin shine effect
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(obj.x + 3, obj.y + 3, 3, 3);
                    } else if (obj.type === 'sign') {
                        // Draw sign text
                        this.ctx.fillStyle = '#000';
                        this.ctx.font = '10px Arial';
                        this.ctx.fillText('?', obj.x + 15, obj.y + 20);
                    }
                });

                // Draw enemies
                this.enemies.forEach(enemy => {
                    if (enemy.alive) {
                        this.ctx.fillStyle = enemy.color;
                        this.ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                        
                        // Eyes
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(enemy.x + 5, enemy.y + 5, 4, 4);
                        this.ctx.fillRect(enemy.x + 15, enemy.y + 5, 4, 4);
                    }
                });

                // Draw projectiles
                this.projectiles.forEach(proj => {
                    this.ctx.fillStyle = proj.color;
                    this.ctx.fillRect(proj.x, proj.y, proj.width, proj.height);
                });

                // Draw wind particles
                if (this.windParticles) {
                    this.windParticles.forEach(particle => {
                        this.ctx.globalAlpha = particle.alpha;
                        this.ctx.fillStyle = '#87CEEB';
                        this.ctx.fillRect(particle.x, particle.y, 4, 2);
                    });
                    this.ctx.globalAlpha = 1;
                }

                // Draw characters
                this.characters.forEach((char, index) => {
                    if (index === this.currentCharacter) {
                        this.drawCharacter(char, index);
                    }
                });

                // Draw flight fuel bar for Mister Underpants
                if (this.currentCharacter === 0) {
                    const char = this.characters[0];
                    const fuelPercent = char.flightFuel / char.maxFlightFuel;
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(char.x, char.y - 15, char.width, 5);
                    this.ctx.fillStyle = fuelPercent > 0.3 ? '#22c55e' : '#ef4444';
                    this.ctx.fillRect(char.x, char.y - 15, char.width * fuelPercent, 5);
                }

                this.ctx.restore();
            }

            updateCoordinateDisplay() {
                const char = this.characters[this.currentCharacter];
                document.getElementById('coordX').textContent = Math.round(char.x);
                document.getElementById('coordY').textContent = Math.round(char.y);
                document.getElementById('coordChar').textContent = this.currentCharacter + 1;
            }

            drawCharacter(char, index) {
                const x = char.x;
                const y = char.y;
                const w = char.width;
                const h = char.height;

                // Show phasing effect for Primm
                if (index === 3 && char.phasing) {
                    this.ctx.globalAlpha = 0.5;
                }

                switch(index) {
                    case 0: // Mister Underpants
                        // Cape hanging down behind (red and bigger)
                        this.ctx.fillStyle = '#dc2626';
                        this.ctx.fillRect(x, y + 12, 12, 25);
                        
                        // Body (underwear)
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillRect(x + 5, y + 20, w - 10, h - 25);
                        
                        // Head
                        this.ctx.fillStyle = '#fdbcbc';
                        this.ctx.fillRect(x + 8, y, w - 16, 18);
                        
                        // Glasses
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillRect(x + 10, y + 6, 4, 4);
                        this.ctx.fillRect(x + 16, y + 6, 4, 4);
                        this.ctx.fillRect(x + 14, y + 8, 2, 1);
                        
                        // Arms
                        this.ctx.fillStyle = '#fdbcbc';
                        this.ctx.fillRect(x + 2, y + 18, 4, 12);
                        this.ctx.fillRect(x + w - 6, y + 18, 4, 12);
                        
                        // Legs
                        this.ctx.fillRect(x + 8, y + h - 10, 6, 10);
                        this.ctx.fillRect(x + 16, y + h - 10, 6, 10);
                        break;

                    case 1: // Windman
                        // Body (shirt)
                        this.ctx.fillStyle = '#60a5fa';
                        this.ctx.fillRect(x + 5, y + 18, w - 10, h - 28);
                        
                        // Pants
                        this.ctx.fillStyle = '#1f2937';
                        this.ctx.fillRect(x + 5, y + h - 15, w - 10, 10);
                        
                        // Head
                        this.ctx.fillStyle = '#fdbcbc';
                        this.ctx.fillRect(x + 8, y, w - 16, 18);
                        
                        // Hair
                        this.ctx.fillStyle = '#8b4513';
                        this.ctx.fillRect(x + 6, y, w - 12, 8);
                        
                        // Arms
                        this.ctx.fillStyle = '#fdbcbc';
                        this.ctx.fillRect(x + 2, y + 18, 4, 12);
                        this.ctx.fillRect(x + w - 6, y + 18, 4, 12);
                        
                        // Fan (when using ability)
                        if (this.keys['Space']) {
                            this.ctx.fillStyle = '#87CEEB';
                            this.ctx.fillRect(x + w, y + 15, 8, 10);
                        }
                        
                        // Legs
                        this.ctx.fillStyle = '#fdbcbc';
                        this.ctx.fillRect(x + 8, y + h - 10, 6, 10);
                        this.ctx.fillRect(x + 16, y + h - 10, 6, 10);
                        break;

                    case 2: // Teibi (child-like)
                        // Body
                        this.ctx.fillStyle = '#22c55e';
                        this.ctx.fillRect(x + 6, y + 16, w - 12, h - 24);
                        
                        // Head (larger for child proportions)
                        this.ctx.fillStyle = '#fdbcbc';
                        this.ctx.fillRect(x + 6, y, w - 12, 16);
                        
                        // Hair
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillRect(x + 4, y, w - 8, 6);
                        
                        // Arms
                        this.ctx.fillStyle = '#fdbcbc';
                        this.ctx.fillRect(x + 2, y + 16, 3, 8);
                        this.ctx.fillRect(x + w - 5, y + 16, 3, 8);
                        
                        // Legs
                        this.ctx.fillRect(x + 9, y + h - 8, 4, 8);
                        this.ctx.fillRect(x + 17, y + h - 8, 4, 8);
                        break;

                    case 3: // Primm (ninja-like)
                        // Body (high-tech suit)
                        this.ctx.fillStyle = '#a855f7';
                        this.ctx.fillRect(x + 4, y + 15, w - 8, h - 25);
                        
                        // Head/Helmet
                        this.ctx.fillStyle = '#581c87';
                        this.ctx.fillRect(x + 7, y, w - 14, 18);
                        
                        // Visor
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.fillRect(x + 9, y + 6, w - 18, 4);
                        
                        // Arms
                        this.ctx.fillStyle = '#a855f7';
                        this.ctx.fillRect(x + 1, y + 15, 4, 12);
                        this.ctx.fillRect(x + w - 5, y + 15, 4, 12);
                        
                        // Katana/Ninjato (on back)
                        this.ctx.fillStyle = '#c0c0c0';
                        this.ctx.fillRect(x + w - 3, y + 5, 2, 12);
                        // Katana handle
                        this.ctx.fillStyle = '#8b4513';
                        this.ctx.fillRect(x + w - 3, y + 4, 2, 3);
                        
                        // Legs
                        this.ctx.fillStyle = '#a855f7';
                        this.ctx.fillRect(x + 8, y + h - 10, 6, 10);
                        this.ctx.fillRect(x + 16, y + h - 10, 6, 10);
                        break;
                }

                if (index === 3 && char.phasing) {
                    this.ctx.globalAlpha = 1;
                }
            }

            showTutorial() {
                const tutorials = [
                    "Mister Underpants: Use arrow keys to move and jump. Hold UP to fly upward! Press SPACE to shoot enemies!",
                    "Windman: Press SPACE to create wind gusts! Blow enemies away from a distance and activate wind platforms!",
                    "Teibi: Press SPACE to shrink down and crawl through the small gap in the wall!",
                    "Primm: Hold C to phase through purple walls. Press SPACE to dash attack enemies!"
                ];

                const tutorialDiv = document.getElementById('tutorialMessage');
                const tutorialText = document.getElementById('tutorialText');
                
                tutorialText.textContent = tutorials[this.currentCharacter];
                tutorialDiv.classList.remove('hidden');
                
                setTimeout(() => {
                    tutorialDiv.classList.add('hidden');
                }, 3000);
            }

            gameOver(message = "Game Over!") {
                const messageDiv = document.getElementById('gameMessage');
                const titleDiv = document.getElementById('gameMessageTitle');
                const textDiv = document.getElementById('gameMessageText');
                
                titleDiv.textContent = 'Game Over!';
                textDiv.textContent = message + ' Press R to restart or click the button below.';
                messageDiv.classList.remove('hidden');
            }

            gameComplete() {
                const messageDiv = document.getElementById('gameMessage');
                const titleDiv = document.getElementById('gameMessageTitle');
                const textDiv = document.getElementById('gameMessageText');
                
                titleDiv.textContent = 'Level Complete!';
                textDiv.textContent = 'Congratulations! You successfully used all characters to reach the goal!';
                messageDiv.classList.remove('hidden');
            }

            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        function restartGame() {
            document.getElementById('gameMessage').classList.add('hidden');
            window.location.reload();
        }

        // Restart method for the game class
        Game.prototype.restartGame = function() {
            document.getElementById('gameMessage').classList.add('hidden');
            window.location.reload();
        };

        // Start the game
        const game = new Game();
        
        // Show initial tutorial
        setTimeout(() => {
            game.showTutorial();
        }, 1000);
    </script>
</body>
</html>